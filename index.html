<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Blast</title>
    
    <link rel="manifest" href="./manifest.json"> 
    
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700;900&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Global Color Settings */
            --main-bg: #f8f8f8;
            --board-bg: #EBEAE4;
            --primary-color: #4CAF50;
            --secondary-color: #FF9800;
            --font-color: #333;
            --shadow-light: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-deep: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        body {
            font-family: 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #f0f4f8 0%, #d9e2ec 100%);
            margin: 0;
            padding-top: 20px;
            color: var(--font-color);
            min-height: 100vh;
        }

        h1 {
            color: #00796b;
            font-weight: 900;
            letter-spacing: 1px;
            margin-bottom: 30px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        #stats-container {
            display: flex;
            gap: 30px;
            margin-bottom: 25px;
        }

        #score-container, #high-score-container {
            font-size: 1.4em;
            font-weight: 700;
            background-color: #ffffff;
            color: #555;
            padding: 10px 20px;
            border-radius: 12px;
            box-shadow: var(--shadow-light);
            border: 1px solid #e0e0e0;
        }
        
        #score, #high-score {
            color: var(--secondary-color);
        }

        /* --- הגדרות הלוח והתאים (ברירת מחדל: מחשב) --- */
        #game-container {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            width: 450px;
            height: 450px;
            border: 8px solid #333;
            background-color: var(--board-bg);
            border-radius: 10px;
            box-shadow: var(--shadow-deep);
            overflow: hidden;
        }

        .cell {
            width: 50px;
            height: 50px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            background-color: #f5f5f5;
            transition: background-color 0.1s, transform 0.1s;
        }

        .cell.highlight {
            border: 2px dashed #FF5733 !important;
            background-color: rgba(255, 255, 255, 0.5) !important;
        }

        .cell.filled {
            border: none;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5), 
                        inset 0 -2px 2px rgba(255, 255, 255, 0.5);
        }

        /* --- Next Blocks --- */
        h2 {
            margin-top: 40px;
            margin-bottom: 15px;
            color: var(--font-color);
        }
        
        #next-blocks-container {
            display: flex;
            gap: 25px;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: var(--shadow-deep);
            margin-bottom: 30px;
        }

        .block-option {
            padding: 10px;
            border: none;
            cursor: grab;
            background-color: #f0f0f0;
            border-radius: 8px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
            transition: transform 0.1s, opacity 0.2s, background-color 0.2s;
            user-select: none;
        }
        
        .block-option:hover:not(.used), .block-option.selected {
             transform: translateY(-3px);
             box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
             background-color: #FFE0B2;
        }

        .block-option:active {
            cursor: grabbing;
        }

        .block-option.used {
            opacity: 0.2;
            pointer-events: none;
        }

        .block-grid {
            display: grid;
        }
        
        .block-cell {
            width: 20px;
            height: 20px;
            box-sizing: border-box;
            border-radius: 3px;
        }
        
        /* --- Floating Block (Touch Drag) --- */
        #floating-block {
            position: absolute; /* מאפשר תנועה חופשית מעל הכל */
            pointer-events: none; /* קריטי! מאפשר ללחוץ דרכו על הלוח */
            z-index: 9999;
            opacity: 0.8;
            display: none; /* נסתר עד תחילת הגרירה */
            transition: none; /* מבטל את הטרנזישן בזמן תנועה */
        }
        
        /* --- Game Over Message --- */
        #message-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            z-index: 1000;
        }

        #message-overlay h2 {
            font-size: 3em;
            color: #ffab00;
            margin-bottom: 10px;
        }

        #message-overlay p {
            font-size: 1.5em;
        }
        
        #message-overlay #final-score {
            font-size: 2em;
            color: #FF5733;
        }

        #message-overlay button {
            padding: 12px 30px;
            margin-top: 30px;
            font-size: 1.3em;
            cursor: pointer;
            border: none;
            border-radius: 25px;
            background-color: #4CAF50;
            color: white;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        #message-overlay button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }
        
        /* --- מדיה קוורי: התאמה למסכים קטנים (טלפונים) --- */
        @media (max-width: 600px) {
            
            h1 {
                font-size: 1.8em;
                margin-bottom: 20px;
            }
            
            /* התאמת גודל הלוח לגודל יחסי של המסך */
            #game-container {
                width: 90vw; 
                height: 90vw;
                max-width: 450px; 
                border-width: 4px;
            }
            
            /* ביטול גודל קבוע לתאים כדי שיתאימו ל-90vw */
            .cell {
                width: auto; 
                height: auto;
            }

            #stats-container {
                gap: 15px;
            }

            #score-container, #high-score-container {
                font-size: 1.1em;
                padding: 8px 15px;
            }

            /* הקטנת גודל הבלוקים הבאים */
            .block-cell {
                width: 15px;
                height: 15px;
            }

            #next-blocks-container {
                gap: 10px;
                padding: 10px;
            }
            
            .block-option {
                 padding: 5px;
            }
        }
    </style>
</head>
<body>
    <h1>Grid Blast</h1>
    
    <div id="stats-container">
        <div id="score-container">Score: <span id="score">0</span></div>
        <div id="high-score-container">High Score: <span id="high-score">0</span></div>
    </div>
    
    <div id="game-container">
        </div>

    <h2>Next Blocks</h2>
    <div id="next-blocks-container">
        </div>
    
    <div id="floating-block" style="display: none;"></div> 

    <div id="message-overlay">
        <h2>Game Over!</h2>
        <p>No remaining moves for any of the available blocks.</p>
        <p>Your Score: <span id="final-score">0</span></p>
        <button onclick="initGame()">Start New Game</button>
    </div>

    <script>
        // --- 1. הגדרות ומשתנים גלובליים ---
        const ROWS = 9;
        const COLS = 9;
        const gameContainer = document.getElementById('game-container');
        const nextBlocksContainer = document.getElementById('next-blocks-container');
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('high-score');
        const messageOverlay = document.getElementById('message-overlay');
        const floatingBlock = document.getElementById('floating-block'); // האלמנט החדש
        
        let board = Array(ROWS).fill(0).map(() => Array(COLS).fill(0));
        let score = 0;
        let highScore = 0;
        let nextBlocks = [];
        let selectedBlockData = null; 
        let selectedBlockIndex = -1;  
        let isTouchDragging = false; // משתנה לניהול מצב גרירה במגע

        // --- 2. Block Templates and Data (נותר זהה) ---
        const ALL_BLOCK_TEMPLATES = [
            { id: 1, shape: [[1]], color: '#FF5733', points: 1 },
            { id: 2, shape: [[1, 1]], color: '#33FF57', points: 2 },
            { id: 3, shape: [[1, 1], [1, 1]], color: '#3357FF', points: 4 },
            { id: 4, shape: [[1, 1, 1]], color: '#FF33A1', points: 3 },
            { id: 5, shape: [[1, 0], [1, 0], [1, 1]], color: '#33FFF6', points: 4 },
            { id: 6, shape: [[1, 1, 1], [0, 1, 0]], color: '#FFBB33', points: 4 },
            { id: 7, shape: [[1, 1, 0], [0, 1, 1]], color: '#8D33FF', points: 4 },
            { id: 8, shape: [[1, 1, 1, 1]], color: '#F00000', points: 4 },
            { id: 10, shape: [[1, 1, 1], [1, 1, 1], [1, 1, 1]], color: '#556B2F', points: 9 }
        ];

        // --- 3. Matrix Rotation, Scoring, High Score, Get Random Block (נותר זהה) ---

        function rotateMatrix(matrix) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            const rotated = Array(cols).fill(0).map(() => Array(rows).fill(0));
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    rotated[c][rows - 1 - r] = matrix[r][c];
                }
            }
            return rotated;
        }

        function loadHighScore() {
            const storedScore = localStorage.getItem('blockBlastHighScore');
            highScore = storedScore ? parseInt(storedScore) : 0;
            highScoreDisplay.textContent = highScore;
        }

        function updateScore(points) {
            score += points;
            scoreDisplay.textContent = score;
            if (score > highScore) {
                highScore = score;
                highScoreDisplay.textContent = highScore;
                localStorage.setItem('blockBlastHighScore', highScore);
            }
        }

        function getRandomBlock() {
            const randomIndex = Math.floor(Math.random() * ALL_BLOCK_TEMPLATES.length);
            let block = ALL_BLOCK_TEMPLATES[randomIndex];
            const rotations = Math.floor(Math.random() * 4); 
            let rotatedShape = block.shape;
            for (let i = 0; i < rotations; i++) {
                rotatedShape = rotateMatrix(rotatedShape);
            }
            return { 
                id: block.id, 
                shape: rotatedShape, 
                color: block.color, 
                points: block.points 
            };
        }

        // --- 4. Next Blocks Logic & Selection Events ---

        function generateNextBlocks() {
            nextBlocks = [];
            for (let i = 0; i < 3; i++) {
                nextBlocks.push({ ...getRandomBlock(), isUsed: false, index: i }); 
            }
            renderNextBlocks();
            checkGameOver();
        }

        function createBlockVisual(blockData) {
            const gridDiv = document.createElement('div');
            gridDiv.classList.add('block-grid');
            
            const numCols = blockData.shape.length > 0 && blockData.shape[0].length > 0 ? blockData.shape[0].length : 1; 
            gridDiv.style.gridTemplateColumns = `repeat(${numCols}, 1fr)`;
            
            blockData.shape.forEach(row => {
                row.forEach(cellValue => {
                    const blockCell = document.createElement('div');
                    blockCell.classList.add('block-cell');
                    if (cellValue === 1) {
                        blockCell.style.backgroundColor = blockData.color;
                        blockCell.style.border = '1px solid #333';
                    }
                    gridDiv.appendChild(blockCell);
                });
            });
            return gridDiv;
        }


        function renderNextBlocks() {
            nextBlocksContainer.innerHTML = '';
            nextBlocks.forEach((block, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.classList.add('block-option');
                if (block.isUsed) {
                    optionDiv.classList.add('used');
                }
                
                optionDiv.dataset.blockIndex = index;

                const gridDiv = createBlockVisual(block);
                optionDiv.appendChild(gridDiv);
                
                // --- מאזינים: גרירת עכבר למחשב ---
                if (window.innerWidth > 600) { 
                    optionDiv.draggable = true;
                    optionDiv.addEventListener('dragstart', handleDragStart);
                    optionDiv.addEventListener('dragend', handleSelectionEnd);
                } else {
                    // --- מאזינים: גרירת מגע לטלפון ---
                    optionDiv.addEventListener('touchstart', handleTouchStart);
                }
                
                nextBlocksContainer.appendChild(optionDiv);
            });

            // מוודא שמאזיני ה-dragover קיימים רק במחשב
            gameContainer.querySelectorAll('.cell').forEach(cell => {
                if (window.innerWidth > 600) {
                    cell.addEventListener('dragover', handleDragOver);
                    cell.addEventListener('dragleave', handleDragLeave);
                    cell.addEventListener('drop', handleDrop);
                }
            });
        }
        
        
        // --- פונקציות גרירת מגע (Touch Drag) ---

        function handleTouchStart(event) {
            const isMobile = window.innerWidth <= 600;
            if (!isMobile) return;

            // מונע גלילת מסך תוך כדי גרירה
            event.preventDefault(); 
            
            isTouchDragging = true;
            
            const targetBlockOption = event.currentTarget;
            const index = parseInt(targetBlockOption.dataset.blockIndex);
            
            selectedBlockData = nextBlocks[index];
            selectedBlockIndex = index;
            
            // יצירת האלמנט הצף
            floatingBlock.innerHTML = '';
            const blockVisual = createBlockVisual(selectedBlockData);
            floatingBlock.appendChild(blockVisual);
            floatingBlock.style.display = 'block';

            // מכין את הבלוק הצף למיקום ההתחלתי
            const touch = event.touches[0];
            updateFloatingBlockPosition(touch.clientX, touch.clientY);
            
            // מוסיף מאזינים גלובליים לתנועה ושחרור
            document.addEventListener('touchmove', handleTouchMove);
            document.addEventListener('touchend', handleTouchEnd);
            
            targetBlockOption.style.opacity = '0.2'; // "מרוקן" את הבלוק המקורי
        }
        
        function handleTouchMove(event) {
            if (!isTouchDragging) return;
            event.preventDefault(); // מונע גלילה נוספת
            
            const touch = event.touches[0];
            updateFloatingBlockPosition(touch.clientX, touch.clientY);

            // בדיקת מיקום הבלוק על הלוח
            const cellUnderTouch = getCellElementFromCoords(touch.clientX, touch.clientY);
            gameContainer.querySelectorAll('.highlight').forEach(cell => cell.classList.remove('highlight')); // ניקוי קודם

            if (cellUnderTouch) {
                const row = parseInt(cellUnderTouch.dataset.row);
                const col = parseInt(cellUnderTouch.dataset.col);
                
                if (canPlaceBlock(row, col, selectedBlockData)) {
                    highlightBlockArea(row, col, selectedBlockData, true);
                } else {
                    highlightBlockArea(row, col, selectedBlockData, false, true);
                }
            }
        }
        
        function handleTouchEnd(event) {
            if (!isTouchDragging) return;
            
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);
            
            // הסתרת האלמנט הצף
            floatingBlock.style.display = 'none';
            isTouchDragging = false;
            
            // קבלת הקואורדינטות של שחרור המגע (הנקודה האחרונה שהאצבע הייתה בה)
            const lastTouch = event.changedTouches[0];
            
            const cellUnderTouch = getCellElementFromCoords(lastTouch.clientX, lastTouch.clientY);
            
            if (cellUnderTouch) {
                const row = parseInt(cellUnderTouch.dataset.row);
                const col = parseInt(cellUnderTouch.dataset.col);

                if (placeBlock(row, col, selectedBlockData)) {
                    nextBlocks[selectedBlockIndex].isUsed = true;
                    checkIfAllUsed();
                } 
            }
            
            // ניקוי ובדיקה
            handleSelectionEnd();
        }
        
        // פונקציית עזר למיקום הבלוק הצף
        function updateFloatingBlockPosition(x, y) {
            // ממקם את הבלוק הצף במרכז המגע
            floatingBlock.style.left = `${x - floatingBlock.offsetWidth / 2}px`;
            floatingBlock.style.top = `${y - floatingBlock.offsetHeight / 2}px`;
        }

        // פונקציית עזר לקבלת האלמנט מתחת לנקודת המגע
        function getCellElementFromCoords(x, y) {
            // משתמש ב-elementFromPoint כדי למצוא את האלמנט שנמצא בנקודה (x, y)
            const element = document.elementFromPoint(x, y);
            
            // מחזיר רק אם האלמנט הוא תא בלוח המשחק
            if (element && element.classList.contains('cell')) {
                return element;
            }
            return null;
        }

        // --- פונקציות גרירת עכבר (Drag & Drop) למחשב ---

        function handleDragStart(event) {
            const index = parseInt(event.currentTarget.dataset.blockIndex);
            selectedBlockData = nextBlocks[index];
            selectedBlockIndex = index;
            event.dataTransfer.setData('text/plain', JSON.stringify(selectedBlockData));
            event.dataTransfer.effectAllowed = 'move';
        }

        function handleSelectionEnd() {
            // נקרא בסוף גרירת עכבר או מגע
            selectedBlockData = null;
            selectedBlockIndex = -1;
            gameContainer.querySelectorAll('.highlight').forEach(cell => cell.classList.remove('highlight'));
            renderNextBlocks(); // רנדור מחדש כדי להחזיר את שקיפות הבלוק המקורי
        }

        function handleDragOver(event) {
            event.preventDefault();
            if (!selectedBlockData) return;

            const cell = event.currentTarget;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            if (canPlaceBlock(row, col, selectedBlockData)) {
                event.dataTransfer.dropEffect = 'move';
                highlightBlockArea(row, col, selectedBlockData, true);
            } else {
                event.dataTransfer.dropEffect = 'none';
                highlightBlockArea(row, col, selectedBlockData, false, true);
            }
        }

        function handleDragLeave(event) {
             const row = parseInt(event.currentTarget.dataset.row);
             const col = parseInt(event.currentTarget.dataset.col);
             highlightBlockArea(row, col, selectedBlockData, false, true); 
        }

        function highlightBlockArea(startRow, startCol, blockData, highlight, clearOnly = false) {
            const shape = blockData.shape;
            const blockRows = shape.length;
            if (blockRows === 0) return;
            const blockCols = shape[0].length;

            if (clearOnly || !highlight) {
                gameContainer.querySelectorAll('.highlight').forEach(cell => cell.classList.remove('highlight'));
            }

            if (highlight) {
                for (let r = 0; r < blockRows; r++) {
                    for (let c = 0; c < blockCols; c++) {
                        if (shape[r][c] === 1) {
                            const boardRow = startRow + r;
                            const boardCol = startCol + c;
                            const cellElement = gameContainer.querySelector(`[data-row="${boardRow}"][data-col="${boardCol}"]`);
                            if (cellElement) {
                                cellElement.classList.add('highlight');
                            }
                        }
                    }
                }
            }
        }
        
        function handleDrop(event) {
            event.preventDefault();
            if (!selectedBlockData) return;
            
            const cell = event.currentTarget;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            if (placeBlock(row, col, selectedBlockData)) {
                nextBlocks[selectedBlockIndex].isUsed = true;
                handleSelectionEnd(); 
                checkIfAllUsed();
            } else {
                 handleSelectionEnd(); 
            }
        }


        // --- 5. Placing Blocks and Fit Check (נותר זהה) ---

        function canPlaceBlock(startRow, startCol, blockData) {
            const shape = blockData.shape;
            const blockRows = shape.length;
            if (blockRows === 0) return false;
            const blockCols = shape[0].length;
            
            for (let r = 0; r < blockRows; r++) {
                for (let c = 0; c < blockCols; c++) {
                    if (shape[r][c] === 1) {
                        const boardRow = startRow + r;
                        const boardCol = startCol + c;
                        
                        if (boardRow < 0 || boardRow >= ROWS || boardCol < 0 || boardCol >= COLS || board[boardRow][boardCol] !== 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function placeBlock(startRow, startCol, blockData) {
            if (!canPlaceBlock(startRow, startCol, blockData)) {
                return false;
            }

            const shape = blockData.shape;
            const blockRows = shape.length;
            const blockCols = shape[0].length;

            for (let r = 0; r < blockRows; r++) {
                for (let c = 0; c < blockCols; c++) {
                    if (shape[r][c] === 1) {
                        const boardRow = startRow + r;
                        const boardCol = startCol + c;
                        
                        board[boardRow][boardCol] = blockData.id;
                        
                        const cellElement = gameContainer.querySelector(`[data-row="${boardRow}"][data-col="${boardCol}"]`);
                        cellElement.classList.add('filled');
                        cellElement.style.backgroundColor = blockData.color;
                    }
                }
            }
            
            updateScore(blockData.points);
            checkAndClearLines(); 
            
            return true;
        }

        function checkIfAllUsed() {
            if (nextBlocks.every(block => block.isUsed)) {
                generateNextBlocks();
            } else {
                checkGameOver();
            }
        }

        // --- 6. Line Clearing and Game Over Logic (נותר זהה) ---

        function checkAndClearLines() {
            let cellsToClear = [];

            // Check Rows
            for (let r = 0; r < ROWS; r++) {
                if (board[r].every(cell => cell !== 0)) {
                    for (let c = 0; c < COLS; c++) {
                        cellsToClear.push({ r, c });
                    }
                }
            }

            // Check Columns
            for (let c = 0; c < COLS; c++) {
                let isColFull = true;
                for (let r = 0; r < ROWS; r++) {
                    if (board[r][c] === 0) {
                        isColFull = false;
                        break;
                    }
                }
                if (isColFull) {
                    for (let r = 0; r < ROWS; r++) {
                        if (!cellsToClear.some(cell => cell.r === r && cell.c === c)) {
                            cellsToClear.push({ r, c });
                        }
                    }
                }
            }
            
            if (cellsToClear.length > 0) {
                clearCells(cellsToClear);
                const bonusPoints = cellsToClear.length * 2; 
                updateScore(bonusPoints);
            }
        }

        function clearCells(cells) {
            cells.forEach(({ r, c }) => {
                board[r][c] = 0; 
                
                const cellElement = gameContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                if (cellElement) {
                    cellElement.classList.remove('filled');
                    cellElement.style.backgroundColor = '';
                }
            });
            checkGameOver();
        }

        function checkGameOver() {
            const unusedBlocks = nextBlocks.filter(block => !block.isUsed);

            if (unusedBlocks.length > 0) {
                let canContinue = false;
                
                for (const block of unusedBlocks) {
                    for (let r = 0; r < ROWS; r++) {
                        for (let c = 0; c < COLS; c++) {
                            if (canPlaceBlock(r, c, block)) {
                                canContinue = true;
                                break;
                            }
                        }
                        if (canContinue) break;
                    }
                    if (canContinue) break;
                }

                if (!canContinue) {
                    gameOverDisplay();
                }
            }
        }

        function gameOverDisplay() {
            document.getElementById('final-score').textContent = score;
            messageOverlay.style.display = 'flex';
        }

        // --- 7. Initialization ---
        
        function createBoard() {
            gameContainer.innerHTML = '';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    gameContainer.appendChild(cell);
                }
            }
        }

        function initGame() {
            board = Array(ROWS).fill(0).map(() => Array(COLS).fill(0));
            score = 0;
            scoreDisplay.textContent = 0;
            messageOverlay.style.display = 'none';

            loadHighScore();
            createBoard();
            generateNextBlocks();
            
            selectedBlockData = null; 
            selectedBlockIndex = -1; 
        }

        initGame();
        
        // --- Registering Service Worker for PWA (נותר זהה) ---
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js')
              .then(registration => {
                console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                console.log('SW registration failed: ', registrationError);
              });
          });
        }
    </script>
</body>
</html>
