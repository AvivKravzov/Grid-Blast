<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Blast</title>
    
    <link rel="manifest" href="./manifest.json"> 
    
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700;900&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Global Color Settings */
            --main-bg: #f8f8f8;
            --board-bg: #EBEAE4;
            --primary-color: #4CAF50;
            --secondary-color: #FF9800;
            --font-color: #333;
            --shadow-light: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-deep: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        body {
            font-family: 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #f0f4f8 0%, #d9e2ec 100%);
            margin: 0;
            padding-top: 20px;
            color: var(--font-color);
        }

        h1 {
            color: #00796b;
            font-weight: 900;
            letter-spacing: 1px;
            margin-bottom: 30px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        #stats-container {
            display: flex;
            gap: 30px;
            margin-bottom: 25px;
        }

        #score-container, #high-score-container {
            font-size: 1.4em;
            font-weight: 700;
            background-color: #ffffff;
            color: #555;
            padding: 10px 20px;
            border-radius: 12px;
            box-shadow: var(--shadow-light);
            border: 1px solid #e0e0e0;
        }
        
        #score, #high-score {
            color: var(--secondary-color);
        }

        #game-container {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            width: 450px;
            height: 450px;
            border: 8px solid #333;
            background-color: var(--board-bg);
            border-radius: 10px;
            box-shadow: var(--shadow-deep);
            overflow: hidden;
        }

        .cell {
            width: 50px;
            height: 50px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            background-color: #f5f5f5;
            transition: background-color 0.1s, transform 0.1s;
        }

        .cell.highlight {
            border: 2px dashed #FF5733 !important;
            background-color: rgba(255, 255, 255, 0.5) !important;
        }

        .cell.filled {
            border: none;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5), 
                        inset 0 -2px 2px rgba(255, 255, 255, 0.5);
        }

        /* --- Next Blocks --- */
        h2 {
            margin-top: 40px;
            margin-bottom: 15px;
            color: var(--font-color);
        }
        
        #next-blocks-container {
            display: flex;
            gap: 25px;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: var(--shadow-deep);
        }

        .block-option {
            padding: 10px;
            border: none;
            cursor: grab;
            background-color: #f0f0f0;
            border-radius: 8px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
            transition: transform 0.1s, opacity 0.2s;
            user-select: none;
        }
        
        .block-option:hover:not(.used) {
             transform: translateY(-3px);
             box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
        }

        .block-option:active {
            cursor: grabbing;
        }

        .block-option.used {
            opacity: 0.2;
            pointer-events: none;
        }

        .block-grid {
            display: grid;
        }
        
        .block-cell {
            width: 20px;
            height: 20px;
            box-sizing: border-box;
            border-radius: 3px;
        }
        
        /* --- Game Over Message --- */
        #message-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            z-index: 1000;
        }

        #message-overlay h2 {
            font-size: 3em;
            color: #ffab00;
            margin-bottom: 10px;
        }

        #message-overlay p {
            font-size: 1.5em;
        }
        
        #message-overlay #final-score {
            font-size: 2em;
            color: #FF5733;
        }

        #message-overlay button {
            padding: 12px 30px;
            margin-top: 30px;
            font-size: 1.3em;
            cursor: pointer;
            border: none;
            border-radius: 25px;
            background-color: #4CAF50;
            color: white;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        #message-overlay button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <h1>Grid Blast</h1>
    
    <div id="stats-container">
        <div id="score-container">Score: <span id="score">0</span></div>
        <div id="high-score-container">High Score: <span id="high-score">0</span></div>
    </div>
    
    <div id="game-container">
        </div>

    <h2>Next Blocks</h2>
    <div id="next-blocks-container">
        </div>

    <div id="message-overlay">
        <h2>Game Over!</h2>
        <p>No remaining moves for any of the available blocks.</p>
        <p>Your Score: <span id="final-score">0</span></p>
        <button onclick="initGame()">Start New Game</button>
    </div>

    <script>
        // *** JavaScript logic remains the same (Drag & Drop, Rotation, Game Over Check) ***

        // Board Settings
        const ROWS = 9;
        const COLS = 9;
        const gameContainer = document.getElementById('game-container');
        const nextBlocksContainer = document.getElementById('next-blocks-container');
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('high-score');
        const messageOverlay = document.getElementById('message-overlay');
        
        let board = Array(ROWS).fill(0).map(() => Array(COLS).fill(0));
        let score = 0;
        let highScore = 0;
        let nextBlocks = [];
        let draggedBlockData = null;
        let draggedBlockIndex = -1;

        // --- 1. Block Templates and Data ---
        const ALL_BLOCK_TEMPLATES = [
            { id: 1, shape: [[1]], color: '#FF5733', points: 1 },
            { id: 2, shape: [[1, 1]], color: '#33FF57', points: 2 },
            { id: 3, shape: [[1, 1], [1, 1]], color: '#3357FF', points: 4 },
            { id: 4, shape: [[1, 1, 1]], color: '#FF33A1', points: 3 },
            { id: 5, shape: [[1, 0], [1, 0], [1, 1]], color: '#33FFF6', points: 4 },
            { id: 6, shape: [[1, 1, 1], [0, 1, 0]], color: '#FFBB33', points: 4 },
            { id: 7, shape: [[1, 1, 0], [0, 1, 1]], color: '#8D33FF', points: 4 },
            { id: 8, shape: [[1, 1, 1, 1]], color: '#F00000', points: 4 },
            { id: 10, shape: [[1, 1, 1], [1, 1, 1], [1, 1, 1]], color: '#556B2F', points: 9 }
        ];

        // --- Matrix Rotation Function (90 degrees clockwise) ---
        function rotateMatrix(matrix) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            
            const rotated = Array(cols).fill(0).map(() => Array(rows).fill(0));
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    rotated[c][rows - 1 - r] = matrix[r][c];
                }
            }
            return rotated;
        }

        // --- Scoring and High Score ---

        function loadHighScore() {
            const storedScore = localStorage.getItem('blockBlastHighScore');
            highScore = storedScore ? parseInt(storedScore) : 0;
            highScoreDisplay.textContent = highScore;
        }

        function updateScore(points) {
            score += points;
            scoreDisplay.textContent = score;
            if (score > highScore) {
                highScore = score;
                highScoreDisplay.textContent = highScore;
                localStorage.setItem('blockBlastHighScore', highScore);
            }
        }

        function getRandomBlock() {
            const randomIndex = Math.floor(Math.random() * ALL_BLOCK_TEMPLATES.length);
            let block = ALL_BLOCK_TEMPLATES[randomIndex];

            const rotations = Math.floor(Math.random() * 4); 

            let rotatedShape = block.shape;
            for (let i = 0; i < rotations; i++) {
                rotatedShape = rotateMatrix(rotatedShape);
            }

            return { 
                id: block.id, 
                shape: rotatedShape, 
                color: block.color, 
                points: block.points 
            };
        }

        // --- 2. Next Blocks Logic & Drag & Drop ---

        function generateNextBlocks() {
            nextBlocks = [];
            for (let i = 0; i < 3; i++) {
                nextBlocks.push({ ...getRandomBlock(), isUsed: false, index: i }); 
            }
            renderNextBlocks();
            checkGameOver();
        }

        function renderNextBlocks() {
            nextBlocksContainer.innerHTML = '';
            nextBlocks.forEach((block, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.classList.add('block-option');
                if (block.isUsed) {
                    optionDiv.classList.add('used');
                }
                optionDiv.dataset.blockIndex = index;

                const gridDiv = document.createElement('div');
                gridDiv.classList.add('block-grid');
                
                const numCols = block.shape.length > 0 && block.shape[0].length > 0 ? block.shape[0].length : 1; 
                gridDiv.style.gridTemplateColumns = `repeat(${numCols}, 1fr)`;
                
                block.shape.forEach(row => {
                    row.forEach(cellValue => {
                        const blockCell = document.createElement('div');
                        blockCell.classList.add('block-cell');
                        if (cellValue === 1) {
                            blockCell.style.backgroundColor = block.color;
                            blockCell.style.border = '1px solid #333';
                        }
                        gridDiv.appendChild(blockCell);
                    });
                });

                optionDiv.appendChild(gridDiv);
                
                optionDiv.draggable = true;
                optionDiv.addEventListener('dragstart', handleDragStart);
                optionDiv.addEventListener('dragend', handleDragEnd);
                
                nextBlocksContainer.appendChild(optionDiv);
            });
        }

        // --- Drag and Drop Handlers ---

        function handleDragStart(event) {
            const index = parseInt(event.target.dataset.blockIndex);
            draggedBlockData = nextBlocks[index];
            draggedBlockIndex = index;
            event.dataTransfer.setData('text/plain', JSON.stringify(draggedBlockData));
            event.dataTransfer.effectAllowed = 'move';
            
            const cells = gameContainer.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.addEventListener('dragover', handleDragOver);
                cell.addEventListener('dragleave', handleDragLeave);
                cell.addEventListener('drop', handleDrop);
            });
        }

        function handleDragEnd() {
            draggedBlockData = null;
            draggedBlockIndex = -1;
            
            const cells = gameContainer.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.classList.remove('highlight');
                cell.removeEventListener('dragover', handleDragOver);
                cell.removeEventListener('dragleave', handleDragLeave);
                cell.removeEventListener('drop', handleDrop);
            });
        }

        function handleDragOver(event) {
            event.preventDefault();
            if (!draggedBlockData) return;

            const cell = event.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            if (canPlaceBlock(row, col, draggedBlockData)) {
                event.dataTransfer.dropEffect = 'move';
                highlightBlockArea(row, col, draggedBlockData, true);
            } else {
                event.dataTransfer.dropEffect = 'none';
                highlightBlockArea(row, col, draggedBlockData, false);
            }
        }

        function handleDragLeave(event) {
             const cell = event.target;
             const row = parseInt(cell.dataset.row);
             const col = parseInt(cell.dataset.col);
             highlightBlockArea(row, col, draggedBlockData, false, true); 
        }

        function highlightBlockArea(startRow, startCol, blockData, highlight, clearOnly = false) {
            const shape = blockData.shape;
            const blockRows = shape.length;
            if (blockRows === 0) return;
            const blockCols = shape[0].length;

            if (clearOnly || !highlight) {
                gameContainer.querySelectorAll('.highlight').forEach(cell => cell.classList.remove('highlight'));
            }

            if (highlight) {
                for (let r = 0; r < blockRows; r++) {
                    for (let c = 0; c < blockCols; c++) {
                        if (shape[r][c] === 1) {
                            const boardRow = startRow + r;
                            const boardCol = startCol + c;
                            const cellElement = gameContainer.querySelector(`[data-row="${boardRow}"][data-col="${boardCol}"]`);
                            if (cellElement) {
                                cellElement.classList.add('highlight');
                            }
                        }
                    }
                }
            }
        }
        
        function handleDrop(event) {
            event.preventDefault();
            if (!draggedBlockData) return;
            
            const cell = event.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            if (placeBlock(row, col, draggedBlockData)) {
                nextBlocks[draggedBlockIndex].isUsed = true;
                renderNextBlocks();
                checkIfAllUsed();
            }
        }

        // --- 3. Placing Blocks and Fit Check ---

        function canPlaceBlock(startRow, startCol, blockData) {
            const shape = blockData.shape;
            const blockRows = shape.length;
            if (blockRows === 0) return false;
            const blockCols = shape[0].length;
            
            for (let r = 0; r < blockRows; r++) {
                for (let c = 0; c < blockCols; c++) {
                    if (shape[r][c] === 1) {
                        const boardRow = startRow + r;
                        const boardCol = startCol + c;
                        
                        if (boardRow < 0 || boardRow >= ROWS || boardCol < 0 || boardCol >= COLS || board[boardRow][boardCol] !== 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function placeBlock(startRow, startCol, blockData) {
            if (!canPlaceBlock(startRow, startCol, blockData)) {
                return false;
            }

            const shape = blockData.shape;
            const blockRows = shape.length;
            const blockCols = shape[0].length;

            for (let r = 0; r < blockRows; r++) {
                for (let c = 0; c < blockCols; c++) {
                    if (shape[r][c] === 1) {
                        const boardRow = startRow + r;
                        const boardCol = startCol + c;
                        
                        board[boardRow][boardCol] = blockData.id;
                        
                        const cellElement = gameContainer.querySelector(`[data-row="${boardRow}"][data-col="${boardCol}"]`);
                        cellElement.classList.add('filled');
                        cellElement.style.backgroundColor = blockData.color;
                    }
                }
            }
            
            updateScore(blockData.points);
            checkAndClearLines(); 
            
            return true;
        }

        function checkIfAllUsed() {
            if (nextBlocks.every(block => block.isUsed)) {
                generateNextBlocks();
            } else {
                checkGameOver();
            }
        }

        // --- 4. Line Clearing and Game Over Logic ---

        function checkAndClearLines() {
            let cellsToClear = [];

            // Check Rows
            for (let r = 0; r < ROWS; r++) {
                if (board[r].every(cell => cell !== 0)) {
                    for (let c = 0; c < COLS; c++) {
                        cellsToClear.push({ r, c });
                    }
                }
            }

            // Check Columns
            for (let c = 0; c < COLS; c++) {
                let isColFull = true;
                for (let r = 0; r < ROWS; r++) {
                    if (board[r][c] === 0) {
                        isColFull = false;
                        break;
                    }
                }
                if (isColFull) {
                    for (let r = 0; r < ROWS; r++) {
                        if (!cellsToClear.some(cell => cell.r === r && cell.c === c)) {
                            cellsToClear.push({ r, c });
                        }
                    }
                }
            }
            
            if (cellsToClear.length > 0) {
                clearCells(cellsToClear);
                const bonusPoints = cellsToClear.length * 2; 
                updateScore(bonusPoints);
            }
        }

        function clearCells(cells) {
            cells.forEach(({ r, c }) => {
                board[r][c] = 0; 
                
                const cellElement = gameContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                if (cellElement) {
                    cellElement.classList.remove('filled');
                    cellElement.style.backgroundColor = '';
                }
            });
            checkGameOver();
        }

        function checkGameOver() {
            const unusedBlocks = nextBlocks.filter(block => !block.isUsed);

            if (unusedBlocks.length > 0) {
                let canContinue = false;
                
                for (const block of unusedBlocks) {
                    for (let r = 0; r < ROWS; r++) {
                        for (let c = 0; c < COLS; c++) {
                            if (canPlaceBlock(r, c, block)) {
                                canContinue = true;
                                break;
                            }
                        }
                        if (canContinue) break;
                    }
                    if (canContinue) break;
                }

                if (!canContinue) {
                    gameOverDisplay();
                }
            }
        }

        function gameOverDisplay() {
            document.getElementById('final-score').textContent = score;
            messageOverlay.style.display = 'flex';
        }

        // --- Initialization ---
        
        function createBoard() {
            gameContainer.innerHTML = '';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    gameContainer.appendChild(cell);
                }
            }
        }

        function initGame() {
            board = Array(ROWS).fill(0).map(() => Array(COLS).fill(0));
            score = 0;
            scoreDisplay.textContent = 0;
            messageOverlay.style.display = 'none';

            loadHighScore();
            createBoard();
            generateNextBlocks();
        }

        initGame();
        
        // --- Registering Service Worker for PWA (Code added here) ---
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js')
              .then(registration => {
                console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                console.log('SW registration failed: ', registrationError);
              });
          });
        }
    </script>
</body>
</html>